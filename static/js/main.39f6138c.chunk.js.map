{"version":3,"sources":["logo.svg","core/Loader.js","core/WasmLoader.js","canvas/CanvasModel.js","canvas/Canvas.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","loader","Loader","instance","this","CanvasKit","canvas","surface","MakeCanvasSurface","id","context","currentContext","skcanvas","getCanvas","paint","SkPaint","setAntiAlias","setColor","Color","setStyle","PaintStyle","Stroke","setStrokeWidth","setPathEffect","SkPathEffect","MakeCorner","path","SkPath","moveTo","lineTo","paths","paints","hold","addEventListener","e","buttons","offsetX","offsetY","copy","Math","random","push","requestAnimationFrame","drawFrame","setCurrentContext","i","length","drawPath","flush","console","log","CanvasKitInit","require","a","Promise","resolve","reject","ready","then","CanvasModel","canvasKit","loadWasm","initCanvas","Canvas","props","canvasRef","React","createRef","canvasModel","current","loadCanvasKit","src","logo","className","alt","width","height","ref","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","registration","unregister","catch","error","message"],"mappings":"oFAAAA,EAAOC,QAAU,IAA0B,kC,6LC+EhCC,G,MAAS,I,WA9EhB,aAII,OAJU,oBACLC,EAAOC,WACRD,EAAOC,SAAWC,MAEfF,EAAOC,S,uDAGPE,EAAWC,GAElB,IAAMC,EAAUF,EAAUG,kBAAkBF,EAAOG,IACnD,GAAKF,EAAL,CAIA,IAAMG,EAAUL,EAAUM,iBACpBC,EAAWL,EAAQM,YAErBC,EAAQ,IAAIT,EAAUU,QAC1BD,EAAME,cAAa,GACnBF,EAAMG,SAASZ,EAAUa,MAAM,EAAG,EAAG,EAAG,IACxCJ,EAAMK,SAASd,EAAUe,WAAWC,QACpCP,EAAMQ,eAAe,GAErBR,EAAMS,cAAclB,EAAUmB,aAAaC,WAAW,KAGtD,IAAIC,EAAO,IAAIrB,EAAUsB,OACzBD,EAAKE,OAAO,GAAI,IAChBF,EAAKG,OAAO,GAAI,IAEhBH,EAAKE,OAAO,IAAK,IACjBF,EAAKG,OAAO,IAAK,IACjBH,EAAKG,OAAO,IAAK,IACjBH,EAAKG,OAAO,IAAK,IAEjBH,EAAKE,OAAO,IAAK,IACjBF,EAAKG,OAAO,IAAK,IACjBH,EAAKE,OAAO,IAAK,IACjBF,EAAKG,OAAO,IAAK,IACjBH,EAAKG,OAAO,IAAK,IAEjB,IAAIC,EAAQ,CAACJ,GACTK,EAAS,CAACjB,GAaVkB,GAAO,EACX1B,EAAO2B,iBAAiB,aAAa,SAACC,GACjCA,EAAEC,SAIHH,EACAN,EAAKG,OAAOK,EAAEE,QAASF,EAAEG,WAEzBvB,EAAQA,EAAMwB,QACRrB,SAASZ,EAAUa,MAAsB,IAAhBqB,KAAKC,SAAgC,IAAhBD,KAAKC,SAAgC,IAAhBD,KAAKC,SAAgBD,KAAKC,SAAW,KAC9GT,EAAOU,KAAK3B,GACZY,EAAO,IAAIrB,EAAUsB,OACrBG,EAAMW,KAAKf,GACXA,EAAKE,OAAOM,EAAEE,QAASF,EAAEG,UAE7BL,GAAO,GAbHA,GAAO,KAeXU,uBA7BA,SAASC,IACTtC,EAAUuC,kBAAkBlC,GAE5B,IAAK,IAAImC,EAAI,EAAGA,EAAId,EAAOe,QAAUD,EAAIf,EAAMgB,OAAQD,IACnDjC,EAASmC,SAASjB,EAAMe,GAAId,EAAOc,IAEvCjC,EAASoC,QAETN,sBAAsBC,WAzCtBM,QAAQC,IAAI,8B,+BCVdC,EAAgBC,EAAQ,I,4CAEf,sBAAAC,EAAA,+EAaJ,IAAIC,SAAQ,SAACC,EAASC,GAmCzBL,IAAgBM,QAAQC,MAAK,SAACrD,GAE1BkD,EAAQlD,UAlDL,4C,sBCDR,IAAMsD,EAAb,WACI,aAAe,oBACXvD,KAAKwD,UAAY,KACjBxD,KAAKE,OAAS,KAHtB,0DAMkBA,GAAQ,IAAD,OACjBF,KAAKE,OAASA,EDNP,WAAf,+BCOQuD,GAAWH,MAAK,SAACrD,GACb,EAAKuD,UAAYvD,EACjBJ,EAAO6D,WAAW,EAAKF,UAAW,EAAKtD,eAVnD,K,iBCCqByD,E,kDACjB,WAAYC,GAAQ,IAAD,8BACf,cAAMA,IACDC,UAAYC,IAAMC,YACvB,EAAKC,YAAc,IAAIT,EAHR,E,gEAOf,IAAMrD,EAASF,KAAK6D,UAAUI,QAC9BjE,KAAKgE,YAAYE,cAAchE,K,+BAI/B,OAAO,6BACP,yBAAKiE,IAAKC,IAAMC,UAAU,WAAWC,IAAI,SACzC,4BAAQC,MAAM,MAAMC,OAAO,MAAMC,IAAKzE,KAAK6D,iB,GAffC,IAAMY,WCArBC,E,uKAGjB,OAAO,kBAAC,EAAD,U,GAHsBb,IAAMY,WCQnBE,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAclC,MACrBC,MAAK,SAAAkC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACL9C,QAAQ8C,MAAMA,EAAMC,c","file":"static/js/main.39f6138c.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","class Loader {\n    constructor(){\n        if (!Loader.instance){\n            Loader.instance = this;\n        }\n        return Loader.instance;\n    }\n\n    initCanvas(CanvasKit, canvas){\n        // CanvasKit and canvas are provided in this scope.\n        const surface = CanvasKit.MakeCanvasSurface(canvas.id);\n        if (!surface) {\n        console.log('Could not make surface');\n        return;\n        }\n        const context = CanvasKit.currentContext();\n        const skcanvas = surface.getCanvas();\n\n        let paint = new CanvasKit.SkPaint();\n        paint.setAntiAlias(true);\n        paint.setColor(CanvasKit.Color(0, 0, 0, 1.0));\n        paint.setStyle(CanvasKit.PaintStyle.Stroke);\n        paint.setStrokeWidth(4.0);\n        // This effect smooths out the drawn lines a bit.\n        paint.setPathEffect(CanvasKit.SkPathEffect.MakeCorner(50));\n\n        // Draw I N K\n        let path = new CanvasKit.SkPath();\n        path.moveTo(80, 30);\n        path.lineTo(80, 80);\n\n        path.moveTo(100, 80);\n        path.lineTo(100, 15);\n        path.lineTo(130, 95);\n        path.lineTo(130, 30);\n\n        path.moveTo(150, 30);\n        path.lineTo(150, 80);\n        path.moveTo(170, 30);\n        path.lineTo(150, 55);\n        path.lineTo(170, 80);\n\n        let paths = [path];\n        let paints = [paint];\n\n        function drawFrame() {\n        CanvasKit.setCurrentContext(context);\n\n        for (let i = 0; i < paints.length && i < paths.length; i++) {\n            skcanvas.drawPath(paths[i], paints[i]);\n        }\n        skcanvas.flush();\n\n        requestAnimationFrame(drawFrame);\n        }\n\n        let hold = false;\n        canvas.addEventListener('mousemove', (e) => {\n        if (!e.buttons) {\n            hold = false;\n            return;\n        }\n        if (hold) {\n            path.lineTo(e.offsetX, e.offsetY);\n        } else {\n            paint = paint.copy();\n            paint.setColor(CanvasKit.Color(Math.random() * 255, Math.random() * 255, Math.random() * 255, Math.random() + .2));\n            paints.push(paint);\n            path = new CanvasKit.SkPath();\n            paths.push(path);\n            path.moveTo(e.offsetX, e.offsetY);\n        }\n        hold = true;\n        });\n        requestAnimationFrame(drawFrame);\n\n    }\n}\n\nexport let loader = new Loader();","\n// const CanvasKitInitModule = require('../canvaskit.wasm');\nconst CanvasKitInit = require('canvaskit-wasm/bin/canvaskit.js')\n// import CanvasKitInitModule from '../../node_modules/canvaskit-wasm/bin/canvaskit.wasm';\nexport default async function loadWasm(){\n    // const exports_ = await import('../../node_modules/canvaskit-wasm/bin/canvaskit.js');\n    /*exports_.default({\n        locateFile: function(path){\n            if(path.endsWith('.wasm')) {\n                return CanvasKitInitModule;\n                }\n                return path;\n        },\n        }).ready().then((CanvasKit) => {\n            this.canvasKit = CanvasKit;\n            this.loader.initCanvas(this.canvasKit, this.canvas);\n    });*/\n    return new Promise((resolve, reject) => {\n        /*const WasmModule = {\n            locateFile: function (path) {\n                if(path.endsWith('.wasm')) {\n                    return CanvasKitInitModule;\n                    }\n                    return path;\n            }\n        };\n        exports_.default(WasmModule).then((Module)=>{\n            delete Module['then'];\n            resolve(Module);\n        });*/\n        /*exports_.default({\n            locateFile: function(path){\n                if(path.endsWith('.wasm')) {\n                    return CanvasKitInitModule;\n                    }\n                    return path;\n            },\n            }).ready().then((CanvasKit) => {\n                resolve(CanvasKit);\n        })*/\n        /*exports_.default({\n            locateFile: function(path){\n                if(path.endsWith('.wasm')) {\n                    //return 'node_modules/canvaskit-wasm/bin/canvaskit.wasm';\n                    return CanvasKitInitModule;\n                    }\n                    return path;\n            }\n        }).ready().then((CanvasKit) => {\n            resolve(CanvasKit);\n            // Code goes here using CanvasKit\n        })*/\n        CanvasKitInit().ready().then((CanvasKit) => {\n            // Code goes here using CanvasKit\n            resolve(CanvasKit);\n        });\n    });\n}\n","\nimport {loader} from '../core/Loader';\nimport loadWasm from '../core/WasmLoader'\nexport class CanvasModel {\n    constructor() {\n        this.canvasKit = null;\n        this.canvas = null;\n    }\n\n    loadCanvasKit(canvas){\n        this.canvas = canvas;\n        loadWasm().then((CanvasKit) => {\n            this.canvasKit = CanvasKit;\n            loader.initCanvas(this.canvasKit, this.canvas);\n        });\n    }\n}","import React from 'react';\nimport {CanvasModel} from './CanvasModel';\nimport logo from '../logo.svg';\n\nexport default class Canvas extends React.Component {\n    constructor(props) {\n        super(props);\n        this.canvasRef = React.createRef();\n        this.canvasModel = new CanvasModel();\n    }\n\n    componentDidMount() {\n        const canvas = this.canvasRef.current\n        this.canvasModel.loadCanvasKit(canvas);\n    }\n\n    render(){\n        return <div>\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <canvas width=\"300\" height=\"300\" ref={this.canvasRef} />\n        </div>\n    }\n}","import React from 'react';\nimport './App.css';\nimport Canvas from \"./canvas/Canvas\";\n\nexport default class App extends React.Component{\n\n  render() {\n    return <Canvas/>\n  };\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}